# Вопрос 8: Триггеры и INSTEAD OF триггеры

## Теоретическая часть

### Определение
**Триггер (Trigger)** — это специальный вид хранимой процедуры, которая **автоматически** выполняется (срабатывает) сервером базы данных при наступлении определенного события. В отличие от обычной процедуры, триггер нельзя вызвать вручную.

### Когда срабатывают триггеры?
События могут быть трех типов:
1.  **DML-события (Манипуляция данными):** `INSERT`, `UPDATE`, `DELETE`. Самый частый кейс.
2.  **DDL-события (Изменение структуры):** `CREATE`, `ALTER`, `DROP` (обычно используется администраторами для защиты схемы).
3.  **Системные события:** Вход/выход пользователя (`LOGON`), старт/остановка сервера.

### Типы DML-триггеров
Триггеры различаются по моменту запуска и частоте срабатывания:

#### 1. По времени (Timing):
*   **BEFORE (До):** Срабатывает **до** фактического изменения данных.
    *   *Зачем:* Валидация данных, автоматическое заполнение полей (например, даты создания), отмена операции (через исключение).
*   **AFTER (После):** Срабатывает **после** успешного изменения данных.
    *   *Зачем:* Логирование (аудит), каскадное обновление других таблиц, отправка уведомлений.

#### 2. По уровню (Level):
*   **Row-level (Для каждой строки):** Триггер выполняется 1 раз для каждой затронутой строки. Если `UPDATE` меняет 100 строк, триггер сработает 100 раз. Имеет доступ к старым (`OLD`) и новым (`NEW`) значениям полей.
*   **Statement-level (Для оператора):** Триггер выполняется 1 раз на весь SQL-запрос, независимо от количества измененных строк.

---

### INSTEAD OF Триггеры
Это особый тип триггеров.
*   **Где применяются:** Только на **Представлениях (Views)**.
*   **Суть:** Они **заменяют** собой стандартную операцию.
*   **Проблема:** Многие представления (особенно с `JOIN`) нельзя обновлять напрямую (СУБД не знает, в какую из таблиц писать данные).
*   **Решение:** Вы создаете `INSTEAD OF INSERT` триггер. Когда кто-то пытается вставить данные в View, триггер перехватывает этот запрос и выполняет свою логику (например, делает два `INSERT` в разные таблицы).

---

## Примеры кода (SQL)

### 1. Триггер BEFORE (Автозаполнение и Валидация)
Задача: Перед сохранением сотрудника автоматически привести email к нижнему регистру и проверить, что зарплата положительная.

```sql
CREATE OR REPLACE TRIGGER trg_emp_before_insert
BEFORE INSERT OR UPDATE ON Employees
FOR EACH ROW
BEGIN
    -- :NEW — это псевдозапись с новыми значениями
    :NEW.email := LOWER(:NEW.email);
    
    IF :NEW.salary < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Зарплата не может быть отрицательной!');
    END IF;
END;
/
```

### 2. Триггер AFTER (Аудит изменений)
Задача: При изменении зарплаты сохранять старое значение и дату изменения в таблицу истории.

```sql
CREATE OR REPLACE TRIGGER trg_emp_audit
AFTER UPDATE OF salary ON Employees
FOR EACH ROW
BEGIN
    INSERT INTO Salary_History (emp_id, old_salary, new_salary, change_date)
    VALUES (:OLD.employee_id, :OLD.salary, :NEW.salary, SYSDATE);
END;
/
```

### 3. Триггер INSTEAD OF (Обновление сложного View)
Допустим, у нас есть представление `v_full_user_info`, которое объединяет таблицы `Users` (логин, пароль) и `Profiles` (адрес, телефон). Напрямую вставить в него нельзя.

```sql
-- Представление
CREATE VIEW v_full_user_info AS
SELECT u.id, u.username, p.address, p.phone
FROM Users u JOIN Profiles p ON u.id = p.user_id;

-- Триггер
CREATE OR REPLACE TRIGGER trg_view_insert
INSTEAD OF INSERT ON v_full_user_info
FOR EACH ROW
BEGIN
    -- 1. Вставляем в таблицу Users
    INSERT INTO Users (id, username) 
    VALUES (:NEW.id, :NEW.username);

    -- 2. Вставляем в таблицу Profiles
    INSERT INTO Profiles (user_id, address, phone)
    VALUES (:NEW.id, :NEW.address, :NEW.phone);
END;
/
```
Теперь команда `INSERT INTO v_full_user_info ...` будет работать корректно.


